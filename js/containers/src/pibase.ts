'use strict'

import Multimap from "./multimap"

import { hmac, hkdf, secureRandom, symmetricEncrypt, symmetricDecrypt, Ciphertext } from "simplecrypto"

/**
 * Simple implementation of \Pi_{bas}.
 *
 * By default, \Pi_{bas} is response-revealing. Set isResponseRevealing = false
 * to have response-hiding properties.
 */
export default class PiBase<K, V> {
    isResponseRevealing: boolean
    entries: Map<string, Ciphertext>

    /**
     * Initializer for the PiBase scheme.
     */
    constructor(isResponseRevealing: boolean = true) {
        this.isResponseRevealing = isResponseRevealing
        this.entries = new Map()
    }

    /**
     * Returns a JSON blob representing the serialized form of the
     * calling PiBase instance.
     */
    toJson(): string {
        return JSON.stringify(this.entries)
    }

    /**
     * Converts the given JSON blob (representing a PiBase instance that
     * was previously serialized with .toJson) into a PiBase instance.
     */
    static fromJson<L, W>(json: string): PiBase<L, W> {
        return Object.assign(new PiBase(), JSON.parse(json))
    }

    /**
     * Encrypts the given multimap instance using the PiBase scheme and
     * stores the encrypted result in the calling PiBase instance.
     *
     * Returns the secret key.
     */
    setup(map: Multimap<K, V>|Map<K, V>): Buffer {
        this.entries = new Map()

        const key = secureRandom(32)
        for (const keyword of map.keys()) {
            const labelKey = hkdf(key, keyword + "label")
            const valueKey = hkdf(key, keyword + "value")
            let counter = 0

            if (map instanceof Map) {
                const value = map.get(keyword);
                const encryptedLabel = hmac(labelKey, counter.toString()).toString()
                const encryptedValue = symmetricEncrypt(valueKey, JSON.stringify(value))
                this.entries.set(encryptedLabel, encryptedValue)
            }
            else { // (map instanceof Multimap)
                for (const value of map.get(keyword) ?? []) {
                    const encryptedLabel = hmac(labelKey, counter.toString()).toString()
                    const encryptedValue = symmetricEncrypt(valueKey, JSON.stringify(value))
                    counter += 1
                    this.entries.set(encryptedLabel, encryptedValue)
                }
            }

        }

        return key
    }

    /**
     * Computes a PiBase search token over the given secret key and
     * keyword.
     */
    static token(key: Buffer, keyword: string, isResponseRevealing: boolean = true): PiBaseSearchToken {
        const labelKey = hkdf(key, keyword + "label")

        if (isResponseRevealing) {
            const valueKey = hkdf(key, keyword + "value")
            return new PiBaseSearchToken(labelKey, valueKey)
        } else {
            return new PiBaseSearchToken(labelKey)
        }
    }

    /**
     * Consumes a search token generated by the PiBase.token algorithm
     * and queries the encrypted structure for the records corresponding
     * to the token. Returns a JavaScript Set corresponding to the result.
     *
     * If this.isResponseRevealing = true, the returned Set is composed
     * of plaintext values. Otherwise, the returned Set is composed of
     * ciphertext values that need to be decrypted by a call to
     * PiBase.resolve.
     */
    query(searchToken: PiBaseSearchToken): Set<string|Ciphertext> {
        const result = new Set<string|Ciphertext>()
        let counter = 0
        while (true) {
            const encryptedLabel = hmac(searchToken.labelKey, counter.toString()).toString()
            const encryptedValue = this.entries.get(encryptedLabel)
            if (encryptedValue) {
                if (this.isResponseRevealing && searchToken.valueKey) {
                    const plaintextValue = JSON.parse(symmetricDecrypt(searchToken.valueKey, encryptedValue))
                    result.add((plaintextValue as string))
                } else {
                    result.add((encryptedValue as Ciphertext))
                }
                counter += 1
            } else {
                break
            }
        }

        return result
    }
}

class PiBaseSearchToken {
    labelKey: Buffer
    valueKey?: Buffer

    constructor(labelKey: Buffer, valueKey?: Buffer|undefined) {
        this.labelKey = labelKey
        this.valueKey = valueKey
    }
}
