'use strict'

const simplecrypto = require("../simplecrypto")

/**
 * Simple implementation of \Pi_{bas}.
 *
 * By default, \Pi_{bas} is response-hiding. Set isResponseRevealing = true to
 * have response-revealing properties.
 */
class PiBase {
    /**
     * Initializer for the PiBase scheme.
     */
    constructor(isResponseRevealing = false) {
        this.isResponseRevealing = isResponseRevealing
    }

    /**
     * Returns a JSON blob representing the serialized form of the
     * calling PiBase instance.
     */
    toJson() {
        return JSON.stringify(this.entries)
    }

    /**
     * Converts the given JSON blob (representing a PiBase instance that
     * was previously serialized with .toJson) into a PiBase instance.
     */
    static fromJson(json) {
        return Object.assign(new PiBase(), JSON.parse(json))
    }

    /**
     * Encrypts the given multimap instance using the PiBase scheme and
     * stores the encrypted result in the calling PiBase instance.
     *
     * Returns the secret key.
     */
    setup(multimap) {
        this.entries = {}

        const key = simplecrypto.secureRandom(32)
        for (const keyword of multimap.keys()) {
            const labelKey = simplecrypto.hkdf(key, keyword + "label")
            const valueKey = simplecrypto.hkdf(key, keyword + "value")
            let counter = 0
            for (const value of multimap.get(keyword)) {
                const encryptedLabel = simplecrypto.hmac(labelKey, counter.toString())
                const encryptedValue = simplecrypto.symmetricEncrypt(valueKey, value)
                counter += 1
                this.entries[encryptedLabel] = encryptedValue
            }
        }

        return key
    }

    /**
     * Computes a PiBase search token over the given secret key and
     * keyword.
     */
    static token(key, keyword, isResponseRevealing = false) {
        const labelKey = simplecrypto.hkdf(key, keyword + "label")
        let searchToken = {labelKey: labelKey}

        if (isResponseRevealing) {
            const valueKey = simplecrypto.hkdf(key, keyword + "value")
            searchToken.valueKey = valueKey
        }

        return searchToken
    }

    /**
     * Consumes a search token generated by the PiBase.token algorithm
     * and queries the encrypted structure for the records corresponding
     * to the token. Returns a JavaScript Set corresponding to the result.
     *
     * If this.isResponseRevealing = true, the returned Set is composed of
     * plaintext values. Otherwise, the returned Set is composed of
     * ciphertext values that need to be decrypted by a call to PiBase.resolve.
     */
    query(searchToken) {
        const result = new Set()
        let counter = 0
        while (true) {
            const encryptedLabel = simplecrypto.hmac(searchToken.labelKey, counter.toString())
            if (!(encryptedLabel in this.entries)) {
                break
            }

            const encryptedValue = this.entries[encryptedLabel]
            if (this.isResponseRevealing) {
                const plaintextValue = simplecrypto.symmetricDecrypt(searchToken.valueKey, encryptedValue)
                result.add(plaintextValue)
            } else {
                result.add(encryptedValue)
            }

            counter += 1
        }

        return result
    }
}

module.exports = PiBase
