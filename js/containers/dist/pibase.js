'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const simplecrypto_1 = require("simplecrypto");
/**
 * Simple implementation of \Pi_{bas}.
 *
 * By default, \Pi_{bas} is response-hiding. Set isResponseRevealing = true to
 * have response-revealing properties.
 */
class PiBase {
    /**
     * Initializer for the PiBase scheme.
     */
    constructor(isResponseRevealing = false) {
        this.isResponseRevealing = isResponseRevealing;
        this.entries = new Map();
    }
    /**
     * Returns a JSON blob representing the serialized form of the
     * calling PiBase instance.
     */
    toJson() {
        return JSON.stringify(this.entries);
    }
    /**
     * Converts the given JSON blob (representing a PiBase instance that
     * was previously serialized with .toJson) into a PiBase instance.
     */
    static fromJson(json) {
        return Object.assign(new PiBase(), JSON.parse(json));
    }
    /**
     * Encrypts the given multimap instance using the PiBase scheme and
     * stores the encrypted result in the calling PiBase instance.
     *
     * Returns the secret key.
     */
    setup(multimap) {
        var _a;
        this.entries = new Map();
        const key = (0, simplecrypto_1.secureRandom)(32);
        for (const keyword of multimap.keys()) {
            const labelKey = (0, simplecrypto_1.hkdf)(key, keyword + "label");
            const valueKey = (0, simplecrypto_1.hkdf)(key, keyword + "value");
            let counter = 0;
            for (const value of (_a = multimap.get(keyword)) !== null && _a !== void 0 ? _a : []) {
                const encryptedLabel = (0, simplecrypto_1.hmac)(labelKey, counter.toString()).toString();
                const encryptedValue = (0, simplecrypto_1.symmetricEncrypt)(valueKey, JSON.stringify(value));
                console.log(counter, encryptedLabel, encryptedValue);
                counter += 1;
                this.entries.set(encryptedLabel, encryptedValue);
                console.log(this.entries.get(encryptedLabel));
            }
        }
        return key;
    }
    /**
     * Computes a PiBase search token over the given secret key and
     * keyword.
     */
    static token(key, keyword, isResponseRevealing = false) {
        const labelKey = (0, simplecrypto_1.hkdf)(key, keyword + "label");
        if (isResponseRevealing) {
            const valueKey = (0, simplecrypto_1.hkdf)(key, keyword + "value");
            return new PiBaseSearchToken(labelKey, valueKey);
        }
        else {
            return new PiBaseSearchToken(labelKey);
        }
    }
    /**
     * Consumes a search token generated by the PiBase.token algorithm
     * and queries the encrypted structure for the records corresponding
     * to the token. Returns a JavaScript Set corresponding to the result.
     *
     * If this.isResponseRevealing = true, the returned Set is composed of
     * plaintext values. Otherwise, the returned Set is composed of
     * ciphertext values that need to be decrypted by a call to PiBase.resolve.
     */
    query(searchToken) {
        const result = new Set();
        let counter = 0;
        console.log(this.entries);
        while (true) {
            const encryptedLabel = (0, simplecrypto_1.hmac)(searchToken.labelKey, counter.toString()).toString();
            const encryptedValue = this.entries.get(encryptedLabel);
            console.log(counter, encryptedLabel, encryptedValue);
            if (encryptedValue) {
                if (this.isResponseRevealing && searchToken.valueKey) {
                    const plaintextValue = JSON.parse((0, simplecrypto_1.symmetricDecrypt)(searchToken.valueKey, encryptedValue));
                    result.add(plaintextValue);
                }
                else {
                    result.add(encryptedValue);
                }
                counter += 1;
            }
            else {
                break;
            }
        }
        return result;
    }
}
exports.default = PiBase;
class PiBaseSearchToken {
    constructor(labelKey, valueKey) {
        this.labelKey = labelKey;
        this.valueKey = valueKey;
    }
}
